"""Excel I/O utilities for Exam Scheduler – MATRIX version.

Reads:
  • TEACHERS, ROOMS, SESSIONS – as before
  • ROOM_SESSION_MATRIX – rows=rooms, cols=sessions, X/1/TRUE/✔ marks active pairs

Writes:
  • DISTRIBUTION sheet (rooms × sessions)
  • WORKLOAD sheet + others (unchanged)

Author: generated by ChatGPT – 25 May 2025
"""
from __future__ import annotations
import openpyxl
from pathlib import Path
from typing import List, Dict, Set, Tuple
from dataclasses import dataclass

CENTER = openpyxl.styles.Alignment(horizontal="center", vertical="center", wrap_text=True)
THIN_BORDER = openpyxl.styles.Border(
    left=openpyxl.styles.Side(style="thin"),
    right=openpyxl.styles.Side(style="thin"),
    top=openpyxl.styles.Side(style="thin"),
    bottom=openpyxl.styles.Side(style="thin"),
)
ITALIC = openpyxl.styles.Font(italic=True)

@dataclass
class InputData:
    teachers: List[str]
    rooms: List[str]
    sessions: List[str]
    active_pairs: Set[Tuple[str,str]]  # (room, session)

@dataclass
class ScheduleOutput:
    supervisors: Dict[Tuple[str,str], List[str]]  # (room,session) -> [t1,t2]
    backups: Dict[str, List[str]]  # session -> [teachers]
    load: Dict[str, int]

# ----------------------------------------------------------------------
# Reading helpers
# ----------------------------------------------------------------------
def _read_col(ws, col: str) -> List[str]:
    return [cell.value for cell in ws[col][1:] if cell.value]

def read_room_session_matrix(ws) -> Set[Tuple[str,str]]:
    """Return set of (room, session) pairs that are marked active."""
    sessions = [c.value for c in ws[1] if c.column > 1 and c.value]
    active: Set[Tuple[str,str]] = set()
    for r in ws.iter_rows(min_row=2, min_col=1, max_col=len(sessions)+1):
        room_id = r[0].value
        if not room_id:
            continue
        for idx, cell in enumerate(r[1:], 0):
            if str(cell.value).strip().upper() in ("1", "X", "TRUE", "✔"):
                active.add((room_id, sessions[idx]))
    return active

def read_input_workbook(path: Path) -> InputData:
    wb = openpyxl.load_workbook(path, data_only=True)
    teachers = _read_col(wb["TEACHERS"], 'A')
    rooms = _read_col(wb["ROOMS"], 'A')
    sessions = _read_col(wb["SESSIONS"], 'A')
    matrix_ws = wb["ROOM_SESSION_MATRIX"]
    active_pairs = read_room_session_matrix(matrix_ws)
    if not active_pairs:
        raise ValueError("ROOM_SESSION_MATRIX is empty – mark at least one pair.")
    return InputData(teachers, rooms, sessions, active_pairs)

# ----------------------------------------------------------------------
# Writing helpers
# ----------------------------------------------------------------------
def write_schedule(wb_path: Path, data: InputData, out: ScheduleOutput, save_to: Path):
    """Create DISTRIBUTION + WORKLOAD sheets and save a copy."""
    wb = openpyxl.load_workbook(wb_path)
    if "DISTRIBUTION" in wb:
        del wb["DISTRIBUTION"]
    ws = wb.create_sheet("DISTRIBUTION", 0)

    # Header row
    ws.append(["Room / Session"] + data.sessions)
    for c in ws[1]:
        c.alignment = CENTER
        c.border = THIN_BORDER

    # Backup row
    ws.append(["Backups"] + [" / ".join(out.backups.get(s, [])) for s in data.sessions])
    for c in ws[2]:
        c.font = ITALIC
        c.alignment = CENTER
        c.border = THIN_BORDER

    # Room rows
    for room in data.rooms:
        row_vals = [room]
        for session in data.sessions:
            if (room, session) in data.active_pairs:
                pair_sup = out.supervisors.get((room, session), [])
                row_vals.append(" / ".join(pair_sup))
            else:
                row_vals.append("")  # inactive – leave blank
        ws.append(row_vals)

    # Styling rows
    for row in ws.iter_rows(min_row=3, max_row=ws.max_row, min_col=1, max_col=ws.max_column):
        for cell in row:
            cell.alignment = CENTER
            cell.border = THIN_BORDER

    ws.freeze_panes = "B3"
    wb.save(save_to)